# Advanced-Computer-Programming
Middleware in Python e Java, con forte approfondimento in Python, tra cui Framework Flask e MongoDB.


Di questo corso è stato introdotto ed ampiamente approfondito il linguaggio Python a 360 gradi, fino alla programmazione concorrente per poi introdurre le Socket sia di tipo TCP che UDP, e il pattern Proxy Skeleton (per delega e per ereditarietà), sia in Python sia in Java. Quest'ultimo pattern dell'ingegneria del software, in cui si disacoppia business logic e parte comunicativa tra client e server, insieme alle Socket, è stato il trampolino di lancio per introdurre i MIDDLEWARE e la loro cruciale importanza all'interno dei grandi sistemi distribuiti. A livello pratico, per i middleware di tipo RPC è stato analizzato GRPC, con protobuf come "contratto" tra client e server, con messaggi sia di tipo unary che stream da ambo i lati(client e server), sia in Python che in Java. Per i Middleware di tipo MOM è stato scelto come Message Broker ActiveMQ, sia per Python che per Java, con rispettivamente il protocollo STOMP per Python e l'interfaccia Java Message Service accompagnato dal servizio di naming Java Naming and Directory Interface per Java, per mandare e ricevere i messaggi. Della semantica MOM ho avuto modo di studiare sia il tipo di comunicazione PTP(point to point, con code tipo mailbox viste anche in Sistemi operativi, comunicazione uno a uno) che PUBLISHER-SUBSCRIBER(con i topic, tipo di comunicazione uno a molti).
Infine, in Python, ho avuto modo di approfondire il Web Framework FLASK per implementare RESTFUL app, definendo le route con rispettivi endpoint e diciamo l'handler "view function", ma soprattutto utilizzare la libreria, lato client, di requests, a me molto cara per fare Web Scraping. Infine, MongoDB per interfacciarsi ai Database NOSQL e fare operazioni CRUD con le rispettive API e sintassi per query, su collection di documents, che passatemi il termine, altro non sono che una lista di Python dictionary. 

Sono state caricate solo le prove d'esame con cui mi sono esercitato e altre varie esercitazioni che ho svolto personalmente, può servire a chi ha già dimistichezza con tali argomenti, per confrontarsi ed esercitarsi.

NB: Essendo file inerenti a esercitazioni "a tempo" relativamente ristretto, qualcosa sicuramente può essere perfezionato. In quel momento il contesto era incentrato su una performance quale un esame, quindi queste sono prove cronometrate, non ho apportato modifiche e le condivido in quanto comunque perfettamente funzionanti. Solo in una, riguardante una prova in GRPC, una feature in cui si calcola una media statistica non è implementata completamente bene, e viene indicato. Per il resto comunque il workflow è fedele a quanto richiesto, magari bisogna rivedere solo qualche piccolo dettaglio di qualche feature.

DIFFICOLTA' RISCONTRATE: "Il mio programma gira su un sistema distribuito quando non funziona per colpa di una macchina di cui non ho mai sentito parlare" -L.Lamport. Nel contesto dei middleware, chiaramente avendo più entità che interoperano tra loro, un bug può avere una ripercussione a cascata. Ho avuto molta difficoltà a capire gli errori che mi notificava l'interprete Python perchè spesso non erano errori legati al rispettivo file ma magari ad un altro file. E quindi non è stato facile il processo d debugging, anche se spesso poi era legato davvero a piccoli dettagli che però fanno la differenza. Altra cosa: una volta aver fatto Python e iniziato e finito subito dopo Java, avevo come la sensazione di aver completamente dimenticato Python. Mi ha aiutato tantissimo, collegare mentalmente analogie e differenze tra Python e Java, a partire dalla OOP, a tutta la parte dei middleware; con un po' di esercitazione in più e iniziando a usare entrambi i linguaggi simultaneamente ad esempio con STOMP Python che manda messaggi a JMS Java tramite il provider ActiveMQ, ho sopperito a questa confusione. Credo sia normale essendo che Python più che non tipizzato, lo definerei totalmente anarchico sotto tale punto di vista. Altra cosa, Proxy skeleton per ereditarietà in Python: una volta definita l'interfaccia, la classe Skeleton la facevo derivare dall'interfaccia ma MI DIMENTICAVO DI FARLA EREDITARE ANCHE DA ABC, in modo tale da renderla classe astratta come giisto che fosse in tal caso; richiamare concettualemente le differenze tra ereditarietà e delega mi ha permesso di non cadere più in tale disattenzione. 

Nota che aggiungo: ho seguito fedelmente il consiglio del professore: "usate la documentazione". Infatti, rispetto a qualche procedimento di qualche esercitazione fatta da lui, mi sono subito buttato a capofitto per trovare soluzioni a modo mio, aiutandomi eventualmente con la documentazione. Una cosa che sono riuscito a rendere più elegante è l'utilizzo del modulo choice della libreria random, per selezionare in maniera random magari un valore tra varie stringhe. E, in secondo luogo una piccola variante in STOMP Python, quando il sender inviava messaggi al receiver. Il prof faceva la concatenazione di un'unica stringa e la mandava, suddividendo le stringhe con il carattere "-", e lato server faceva l'unmarshalling dei messaggi tramite messaggio_ricevuto.split("-"), ricevendo i vari messaggi e accedendo in maniera indicizzata. Io invece inizialmente sfruttavo gli headers, che praticamente sono dei dictionary: quindi nel body inserivo il tipo di richiesta (una stringa) e usavo gli headers per aggiungere le altre info; lato receiver usavo il body per discriminare il tipo di richiesta e accedevo agli altri messaggi, che erano i values del dictionary (cioè gli headers), tramite le keys. Glielo mostrai a ricevimento e confermo che va bene come strada, infatti comunque runnava corettamente.

Ci sarebbero tante altre cose da dire, ma mi fermo qui. Davvero bel corso, ci ho sbattuto la testa più volte per interiorizzare DAVVERO i concetti e avere chiaro il quadro generale, ma ne è valsa la pena.


