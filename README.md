# Advanced-Computer-Programming
Middleware in Python e Java, con forte approfondimento in Python, tra cui Framework Flask e MongoDB.


Di questo corso è stato introdotto ed ampiamente approfondito il linguaggio Python a 360 gradi, fino alla programmazione concorrente per poi introdurre le Socket sia di tipo TCP che UDP, e il pattern Proxy Skeleton (per delega e per ereditarietà), sia in Python sia in Java. Quest'ultimo pattern dell'ingegneria del software, in cui si disacoppia business logic e parte comunicativa tra client e server, insieme alle Socket, è stato il trampolino di lancio per introdurre i Middleware e la loro cruciale importanza all'interno dei grandi sistemi distribuiti. A livello pratico, per i middleware di tipo RPC è stato analizzato GRPC con protobuf come "contratto" tra client e server, con messaggi di tipo unary che stream da ambo i lati, sia in Python che in Java. Per i Middleware di tipo MOM è stato scelto come Message Broker ActiveMQ, sia per Python che per Java, con rispettivamente il protocollo STOMP per Python e l'interfaccia Java Message Service accompagnato dal servizio di naming Java Naming and Directory Interface per Java, per mandare e ricevere i messaggi. Della semantica MOM ho avuto modo di studiare sia il tipo di comunicazione PTP(point to point, con code tipo mailbox viste anche in Sistemi operativi, comunicazione uno a uno) che PUBLISHER-SUBSCRIBER(con i topic, tipo di comunicazione uno a molti).
Infine, in Python, ho visionato il Web Framework FLASK per implementare RESTFUL app, definendo le route con rispettivi endpoint e  diciamo l'handler "view function", ma soprattutto utilizzare la libreria, lato client, di requests, a me molto cara per fare Web Scraping. Infine MongoDB per interfacciarsi ai Database NOSQL e fare operazioni CRUD con le rispettive API e sintassi per le query, su collection di documents, che passatemi il termine, altro non sono che una lista di Python dictionary. 

Sono state caricate solo le prove d'esame con cui mi sono esercitato e altre varie esercitazioni che ho svolto personalmente, può servire a chi ha già dimistichezza con tali argomenti, per confrontarsi ed esercitarsi.

NB: Essendo file inerenti a esercitazioni "a tempo" relativamente ristretto, qualcosa sicuramente può essere perfezionato. In quel momento il contesto era incentrato su una performance quale un esame, quindi queste sono prove cronometrate, non ho apportato modifiche e le condivido in quanto comunque perfettamente funzionanti. Solo in una, riguardante una prova in GRPC, una feature in cui si calcola una media statistica non è implementata completamente bene, e viene indicato. Per il resto comunque il workflow è fedele a quanto richiesto, magari bisogna rivedere solo qualche piccolo dettaglio di qualche feature.

DIFFICOLTA' RISCONTRATE: "Il mio programma gira su un sistema distribuito quando non funziona per colpa di una macchina di cui non ho mai sentito parlare" -L.Lamport. Nel contesto dei middleware, chiaramente avendo più entità che interoperano tra loro, un bug può avere una ripercussione a cascata. Ho avuto molta difficoltà a capire gli errori che mi notificava l'interprete Python perchè spesso non erano errori legati al rispettivo file ma magari ad un altro file che inviava il messaggio. E quindi non è stato facile il processo d debugging, anche se spesso poi era legato davvero a piccoli dettagli che però fanno la differenza. Altra cosa: una volta aver fatto Python e iniziato e finito subito dopo Java, avevo come la sensazione di aver completamente dimenticato Python. Mi ha aiutato tantissimo, collegare analogie e differenze tra Python e Java, a partire dalla OOP, a tutta la parte dei middleware; con un po' di esercitazione in più e iniziando a usare entrambi i linguaggi simultaneamente ad esempio con STOMP Python che manda messaggi a JMS Java tramite il provider ActiveMQ, ho sopperito a questa confusione. Credo sia normale essendo che Python più che non tipizzato, lo definerei totalmente anarchico sotto tale punto di vista. Altra cosa, Proxy skeleton per ereditarietà in Python: una volta definita l'interfaccia, la classe Skeleton la facevo derivare dall'interfaccia ma MI DIMENTICAVO DI FARLA EREDITARE DA ABC, in modo da renderla classe astratta; richiamare concettualemente le differenze tra ereditarietà e delega mi ha permesso di non cadere più in tale disattenzione. 

Ci sarebbero tante altre cose da dire, ma mi fermo qui. Davvero bel corso, ci ho sbattuto la testa più volte per interiorizzare DAVVERO i concetti e avere chiaro il quadro generale, ma ne è valsa la pena.


